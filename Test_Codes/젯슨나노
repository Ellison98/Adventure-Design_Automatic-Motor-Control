import cv2
import numpy as np
import serial
import time

# 시리얼 통신 설정 (아두이노와 연결된 포트로 변경)
SERIAL_PORT = '/dev/ttyACM0'  # 실제 연결된 포트로 변경 필요
BAUD_RATE = 9600

# 시리얼 포트 열기
try:
    ser = serial.Serial(SERIAL_PORT, BAUD_RATE, timeout=1)
    time.sleep(2)  # 시리얼 연결 안정화 대기
except serial.SerialException as e:
    print(f"시리얼 포트 열기 실패: {e}")
    exit()

def grayscale(frame):
    return cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

def gaussian_blur(frame, kernel_size):
    return cv2.GaussianBlur(frame, (kernel_size, kernel_size), 0)

def canny(frame, low_threshold, high_threshold):
    return cv2.Canny(frame, low_threshold, high_threshold)

def region_of_interest(frame, vertices):
    mask = np.zeros_like(frame)
    cv2.fillPoly(mask, vertices, 255)
    return cv2.bitwise_and(frame, mask)

def hough_lines(frame, rho, theta, threshold, min_line_len, max_line_gap):
    return cv2.HoughLinesP(frame, rho, theta, threshold, np.array([]),
                        minLineLength=min_line_len, maxLineGap=max_line_gap)

def calculate_slope_intercept(line):
    x1, y1, x2, y2 = line
    if x2 - x1 == 0:
        return None, None
    slope = (y2 - y1) / (x2 - x1)
    intercept = y1 - slope * x1
    return slope, intercept

def filter_and_average_line(lines, width, height):
    left_lines = []
    right_lines = []

    for line in lines:
        for x1, y1, x2, y2 in line:
            slope, intercept = calculate_slope_intercept((x1, y1, x2, y2))
            if slope is None:
                continue
            if 0.5 < abs(slope) < 2:
                if slope < 0:
                    left_lines.append((slope, intercept))
                elif slope > 0:
                    right_lines.append((slope, intercept))

    def average_lines(lines):
        if not lines:
            return None
        slope = np.mean([line[0] for line in lines])
        intercept = np.mean([line[1] for line in lines])
        return slope, intercept

    left_avg = average_lines(left_lines)
    right_avg = average_lines(right_lines)

    def calculate_line_coordinate(slope, intercept):
        if slope is None or intercept is None:
            return None
        y1 = height
        y2 = int(height * 0.6)
        x1 = int((y1 - intercept) / slope)
        x2 = int((y2 - intercept) / slope)
        return (x1, y1, x2, y2)

    left_line = calculate_line_coordinate(*left_avg) if left_avg else None
    right_line = calculate_line_coordinate(*right_avg) if right_avg else None

    return left_line, right_line

def calculate_center_line(left_line, right_line):
    if left_line is None or right_line is None:
        return None

    x1_left, y1_left, x2_left, y2_left = left_line
    x1_right, y1_right, x2_right, y2_right = right_line

    x1_center = (x1_left + x1_right) // 2
    y1_center = (y1_left + y1_right) // 2
    x2_center = (x2_left + x2_right) // 2
    y2_center = (y2_left + y2_right) // 2

    return (x1_center, y1_center, x2_center, y2_center)

def calculate_steering_angle(center_x, frame_width, max_steering_angle=30):
    deviation = center_x - (frame_width / 2)
    steering_angle = np.clip((deviation / (frame_width / 2)) * max_steering_angle, -max_steering_angle, max_steering_angle)
    return int(steering_angle)

def draw_lane_lines(frame, lines, color=(0, 255, 0), thickness=5):
    for line in lines:
        if line is not None:
            x1, y1, x2, y2 = line
            cv2.line(frame, (x1, y1), (x2, y2), color, thickness)

def draw_reference_line(frame, height, width):
    start_point = (int(width * 0.5), int(height * 0.8))
    end_point = (int(width * 0.5), int(height))
    cv2.line(frame, start_point, end_point, (0, 0, 255), 3)

def main():
    # 카메라 설정 (필요에 따라 조정)
    gst_pipeline = (
        "nvarguscamerasrc sensor-id=0 ! "
        "video/x-raw(memory:NVMM), width=1280, height=720, format=(string)NV12, framerate=30/1 ! "
        "nvvidconv flip-method=0 ! "
        "video/x-raw, format=(string)BGRx ! videoconvert ! video/x-raw, format=(string)BGR ! appsink"
    )
    cap = cv2.VideoCapture(gst_pipeline, cv2.CAP_GSTREAMER)
    if not cap.isOpened():
        print("카메라를 열 수 없습니다.")
        return

    while True:
        ret, frame = cap.read()
        if not ret:
            print("프레임을 읽을 수 없습니다.")
            break

        frame = cv2.resize(frame, (640, 480))
        height, width = frame.shape[:2]

        gray = grayscale(frame)
        blur = gaussian_blur(gray, 5)
        edges = canny(blur, 50, 150)

        vertices = np.array([[
            (0, height),
            (0, int(height * 0.5)),
            (width, int(height * 0.5)),
            (width, height)
        ]], dtype=np.int32)
        roi = region_of_interest(edges, vertices)

        # ROI 이미지 표시
        cv2.imshow("ROI Image", roi)

        lines = hough_lines(roi, 1, np.pi/180, threshold=30, min_line_len=20, max_line_gap=5)

        if lines is not None:
            left_line, right_line = filter_and_average_line(lines, width, height)
            center_line = calculate_center_line(left_line, right_line)

            draw_lane_lines(frame, [left_line, right_line])
            draw_lane_lines(frame, [center_line], color=(255, 0, 0), thickness=3)

            if center_line:
                center_x = (center_line[0] + center_line[2]) // 2
                steering_angle = calculate_steering_angle(center_x, width)

                # 스티어링 값 매핑 (예: -30~30 -> 0~255)
                steer_value = int((steering_angle + 30) / 60 * 255)
                # 속도는 일정하게 유지 (예: 150)
                throttle_value = 150

                # 스티어링과 속도 값을 아두이노로 전송
                # 2바이트씩 전송 (예: steer_value, throttle_value)
                ser.write(bytes([steer_value, throttle_value]))

                # 디버깅용 텍스트 출력
                cv2.putText(frame, f'Steering Angle: {steering_angle} deg',
                            (50, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2, cv2.LINE_AA)

        draw_reference_line(frame, height, width)

        cv2.imshow("Lane Detection", frame)

        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    cap.release()
    cv2.destroyAllWindows()
    ser.close()

if __name__ == "__main__":
    main()
